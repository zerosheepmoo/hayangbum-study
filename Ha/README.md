# 어서오세요!
이곳은 Team.hayangbum의 멤버 ha의 숙제 제출공간입니다

# 기록합니다!
앞으로 이 공간(README.md)은 Assignment 및 Python studying을 진행하면서 겪는 오류와 문제, 이슈들을 나열할 예정입니다.

## Ass_1

### 재귀 함수 사용 중의 실수
진수 계산을 하기 위한 함수를 짜면서, 재귀함수를 이용함에 어려움이 있었습니다
진수 계산은 잘 했는데, 재귀함수를 빠져나오면서 변수들이 초기화되는 문제에 닥쳤거든요.

관련 이슈입니다

https://github.com/zerosheepmoo/hayangbum-study/issues/9#issue-536928456

이 문제의 핵심 원인은, 전역 변수를 사용하지 않는다는 데 있습니다. 사실, 재귀에서 변수는 초기화되는 것이 아닙니다.
1. Recursion으로 들어가면서 새로운 j_array가 선언됩니다
1. 하나 이상의 Recursion이 완료되면서, 그 안의 j_array는 전부 사용하였으므로 삭제됩니다.
1. 밖에 있던 j_array만 남습니다.
1. 이 과정이 마치 j_array가 초기화 되는 것 처럼 보일 뿐입니다.

그에 따른 해결 방법은 다음과 같습니다.
1. j_array 문자열을 전역 변수로 선언하여 사용한다.
1. Recursion이 단순히 j_array에 값을 저장하는 방식이 아닌, j_array에 리턴값을 더하도록 설계한다.

### 내부 함수 이용과 조건문의 이용
#### Hex(n%base)[2:]
위 코드는 진법을 변환하는 과정에서, 10 이상의 나머지가 나올 경우, 각각 A,B,...,F에 대응되게 하기 위한 것입니다.
코드에 오류는 없고, if-else statement를 사용하는 것 보다 가독성이 뛰어난 것은 사실입니다. 그러나, 내부 함수 `Hex()`를 이용하기 때문에, 실행 속도가 꽤 떨어집니다.
> 특히 Python과 같은 고등 언어에서는, 이 속도 문제를 신경써주는 것이 좋습니다.
> 고등 언어와 저등 언어의 기준은, 얼마나 기계적이냐(저등)<->인간적이냐(고등) 으로 합니다.

#### j_array+=str(n%base)
위 코드를 통해 진법을 변환할 시, 13_(10)이 1011_(2)로 나올 것입니다. 진법 변환 Algorithm 자체가 나머지를 나열하고, 거꾸로 읽어야 하기 때문입니다. 이를 극복하기 위해서 저는 Return시에 `j_array[::-1]`을 수행했었습니다. 그러나, `[::-1]`과 같은 코드(거꾸로 뒤집은 과정)은 `Hex()`의 사용처럼, 상당한 시간을 필요로 합니다.

그러나, 만약 코드를 `+=`의 사용 대신
`j_array = str(n%base) + j_array`로 작성한다면, 문자열의 더하는 순서가 바뀌게 됩니다.
결과적으로, 13_(10)이 1101_(2)로 변환됩니다.